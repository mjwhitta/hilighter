#!/usr/bin/env ruby

require "hilighter"
require "io/wait"
require "optparse"

### Helpers begin
def err(msg)
    puts("[!] #{msg}".red)
end
def errx(msg)
    raise Exception.new(msg)
end
def good(msg)
    puts("[+] #{msg}".green)
end
def info(msg)
    puts("[*] #{msg}".white)
end
def subinfo(msg)
    puts("[=] #{msg}".cyan)
end
def warn(msg)
    puts("[-] #{msg}".yellow)
end
### Helpers end

class HilighterExit
    GOOD = 0
    INVALID_OPTION = 1
    INVALID_ARGUMENT = 2
    MISSING_ARGUMENT = 3
    EXTRA_ARGUMENTS = 4
    EXCEPTION = 5
    AMBIGUOUS_ARGUMENT = 6
end

def parse(args)
    options = Hash.new
    options["action"] = "default"
    options["verbose"] = false

    info = [
        "Hilights the text from stdin using the methods passed on",
        "the CLI."
    ].join(" ")

    parser = OptionParser.new do |opts|
        opts.summary_width = 19

        opts.banner = [
            "Usage: #{File.basename($0)} [OPTIONS] [color1]...",
            "[colorN]"
        ].join(" ")

        opts.on("", "DESCRIPTION")

        info.wrap(76).each_line do |line|
            opts.on("    #{line.chomp}")
        end

        opts.on("", "OPTIONS")

        opts.on("-h", "--help", "Display this help message") do
            puts(opts)
            exit HilighterExit::GOOD
        end

        opts.on("--[no-]color", "Disable colorized output") do |c|
            Hilighter.disable if (!c)
        end

        opts.on(
            "-s",
            "--sample",
            "Show sample foreground/background colors"
        ) do
            options["action"] = "sample"
        end

        opts.on("-t", "--table", "Show the color table") do
            options["action"] = "table"
        end

        opts.on(
            "-v",
            "--verbose",
            "Show backtrace when error occurs"
        ) do
            options["verbose"] = true
        end

        opts.on("-V", "--version", "Show version") do
            __FILE__.match(/hilighter-(\d+\.\d+\.\d+)/) do |m|
                puts(m[1])
            end
            exit HilighterExit::GOOD
        end
    end

    begin
        parser.parse!
    rescue OptionParser::InvalidOption => e
        puts(e.message)
        puts(parser)
        exit HilighterExit::INVALID_OPTION
    rescue OptionParser::InvalidArgument => e
        puts(e.message)
        puts(parser)
        exit HilighterExit::INVALID_ARGUMENT
    rescue OptionParser::MissingArgument => e
        puts(e.message)
        puts(parser)
        exit HilighterExit::MISSING_ARGUMENT
    rescue OptionParser::AmbiguousOption => e
        puts(e.message)
        puts(parser)
        exit Exit::AMBIGUOUS_ARGUMENT
    end

    return options
end

begin
    options = parse(ARGV)
rescue Interrupt
    # Exit gracefully on ^C
    exit HilighterExit::GOOD
end

begin
    case options["action"]
    when "sample"
        Hilighter.sample
    when "table"
        Hilighter.table
    else
        bad = Array.new
        loop do
            # Get input
            input = STDIN.gets

            # Break if EOF, otherwise remove existing color codes
            break if (input.nil?)

            # Apply all requested color codes
            ARGV.each do |color|
                begin
                    input = input.send(color)
                rescue NoMethodError
                    bad.push(color)
                end
            end
            break if (!bad.empty?)

            # Output
            puts(input)
        end
        puts("Invalid colors: #{bad.join(", ")}") if (!bad.empty?)
    end
rescue Interrupt
    # Exit gracefully on ^C
rescue Errno::EPIPE
    # Do nothing. This can happen if piping to another program such as
    # less. Usually if less is closed before we're done with STDOUT.
rescue Exception => e
    $stderr.puts(
        [
            "Oops! Looks like an error has occured! If the error",
            "persists, file a bug at:"
        ].join(" ").wrap
    )
    $stderr.puts
    $stderr.puts("  https://gitlab.com/mjwhitta/hilighter/issues")
    $stderr.puts
    $stderr.puts(
        [
            "Maybe the message below will help. If not, you can use",
            "the --verbose flag to get a backtrace."
        ].join(" ").wrap
    )
    $stderr.puts

    $stderr.puts(e.message.white.on_red)
    if (options["verbose"])
        e.backtrace.each do |line|
            $stderr.puts(line.light_yellow)
        end
    end
    exit HilighterExit::EXCEPTION
end
exit HilighterExit::GOOD
